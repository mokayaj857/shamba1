import { caller, getCallStack, rmRf } from "@ark/fs";
import { performance } from "node:perf_hooks";
import { ensureCacheDirs, getConfig } from "../config.js";
import { chainableNoOpProxy } from "../utils.js";
import { await1K } from "./await1k.js";
import { compareToBaseline, queueBaselineUpdateIfNeeded } from "./baseline.js";
import { call1K } from "./call1k.js";
import { createTimeComparison, createTimeMeasure } from "./measure.js";
import { createBenchTypeAssertion } from "./type.js";
let benchHasRun = false;
const benchFn = (name, fn, options) => {
    const qualifiedPath = [...currentSuitePath, name];
    console.log(`ðŸŒï¸  ${qualifiedPath.join("/")}`);
    const ctx = getBenchCtx(qualifiedPath, fn.constructor.name === "AsyncFunction", options);
    if (!benchHasRun) {
        rmRf(ctx.cfg.cacheDir);
        ensureCacheDirs();
        benchHasRun = true;
    }
    ctx.benchCallPosition = caller();
    if (typeof ctx.cfg.filter === "string" &&
        !qualifiedPath.includes(ctx.cfg.filter))
        return chainableNoOpProxy;
    else if (Array.isArray(ctx.cfg.filter) &&
        ctx.cfg.filter.some((segment, i) => segment !== qualifiedPath[i]))
        return chainableNoOpProxy;
    const assertions = new BenchAssertions(fn, ctx);
    Object.assign(assertions, createBenchTypeAssertion(ctx));
    return assertions;
};
export const bench = Object.assign(benchFn, {
    baseline: () => { }
});
export const stats = {
    mean: (callTimes) => {
        const totalCallMs = callTimes.reduce((sum, duration) => sum + duration, 0);
        return totalCallMs / callTimes.length;
    },
    median: (callTimes) => {
        const middleIndex = Math.floor(callTimes.length / 2);
        const ms = callTimes.length % 2 === 0 ?
            (callTimes[middleIndex - 1] + callTimes[middleIndex]) / 2
            : callTimes[middleIndex];
        return ms;
    }
};
class ResultCollector {
    results = [];
    benchStart = performance.now();
    bounds;
    lastInvocationStart;
    ctx;
    constructor(ctx) {
        this.ctx = ctx;
        // By default, will run for either 5 seconds or 100_000 call sets (of 1000 calls), whichever comes first
        this.bounds = {
            ms: 5000,
            count: 100_000,
            ...ctx.options.until
        };
        this.lastInvocationStart = -1;
    }
    start() {
        this.ctx.options.hooks?.beforeCall?.();
        this.lastInvocationStart = performance.now();
    }
    stop() {
        this.results.push((performance.now() - this.lastInvocationStart) / 1000);
        this.ctx.options.hooks?.afterCall?.();
    }
    done() {
        const metMsTarget = performance.now() - this.benchStart >= this.bounds.ms;
        const metCountTarget = this.results.length >= this.bounds.count;
        return metMsTarget || metCountTarget;
    }
}
const loopCalls = (fn, ctx) => {
    const collector = new ResultCollector(ctx);
    while (!collector.done()) {
        collector.start();
        // we use a function like this to make 1k explicit calls to the function
        // to avoid certain optimizations V8 makes when looping
        call1K(fn);
        collector.stop();
    }
    return collector.results;
};
const loopAsyncCalls = async (fn, ctx) => {
    const collector = new ResultCollector(ctx);
    while (!collector.done()) {
        collector.start();
        await await1K(fn);
        collector.stop();
    }
    return collector.results;
};
export class BenchAssertions {
    label;
    lastCallTimes;
    fn;
    ctx;
    constructor(fn, ctx) {
        this.fn = fn;
        this.ctx = ctx;
        this.label = `Call: ${ctx.qualifiedName}`;
    }
    applyCallTimeHooks() {
        if (this.ctx.options.fakeCallMs !== undefined) {
            const fakeMs = this.ctx.options.fakeCallMs === "count" ?
                this.lastCallTimes.length
                : this.ctx.options.fakeCallMs;
            this.lastCallTimes = this.lastCallTimes.map(() => fakeMs);
        }
    }
    callTimesSync() {
        if (!this.lastCallTimes) {
            this.lastCallTimes = loopCalls(this.fn, this.ctx);
            this.lastCallTimes.sort();
        }
        this.applyCallTimeHooks();
        return this.lastCallTimes;
    }
    async callTimesAsync() {
        if (!this.lastCallTimes) {
            this.lastCallTimes = await loopAsyncCalls(this.fn, this.ctx);
            this.lastCallTimes.sort();
        }
        this.applyCallTimeHooks();
        return this.lastCallTimes;
    }
    createAssertion(name, baseline, callTimes) {
        if (name === "mark")
            return this.markAssertion(baseline, callTimes);
        const ms = stats[name](callTimes);
        const comparison = createTimeComparison(ms, baseline);
        console.group(`${this.label} (${name}):`);
        compareToBaseline(comparison, this.ctx);
        console.groupEnd();
        queueBaselineUpdateIfNeeded(createTimeMeasure(ms), baseline, {
            ...this.ctx,
            lastSnapFunctionName: name
        });
        return this.getNextAssertions();
    }
    markAssertion(baseline, callTimes) {
        console.group(`${this.label}:`);
        const markEntries = (baseline ?
            Object.entries(baseline)
            // If nothing was passed, gather all available baselines by setting their values to undefined.
            : Object.entries(stats).map(([kind]) => [kind, undefined]));
        const markResults = Object.fromEntries(markEntries.map(([kind, kindBaseline]) => {
            console.group(kind);
            const ms = stats[kind](callTimes);
            const comparison = createTimeComparison(ms, kindBaseline);
            compareToBaseline(comparison, this.ctx);
            console.groupEnd();
            return [kind, comparison.updated];
        }));
        console.groupEnd();
        queueBaselineUpdateIfNeeded(markResults, baseline, {
            ...this.ctx,
            lastSnapFunctionName: "mark"
        });
        return this.getNextAssertions();
    }
    getNextAssertions() {
        return createBenchTypeAssertion(this.ctx);
    }
    createStatMethod(name, baseline) {
        if (this.ctx.isAsync) {
            return new Promise(resolve => {
                this.callTimesAsync().then(callTimes => {
                    resolve(this.createAssertion(name, baseline, callTimes));
                }, e => {
                    this.addUnhandledBenchException(e);
                    resolve(chainableNoOpProxy);
                });
            });
        }
        let assertions = chainableNoOpProxy;
        try {
            assertions = this.createAssertion(name, baseline, this.callTimesSync());
        }
        catch (e) {
            this.addUnhandledBenchException(e);
        }
        return assertions;
    }
    addUnhandledBenchException(reason) {
        const message = `Bench ${this.ctx.qualifiedName} threw during execution:\n${String(reason)}`;
        console.error(message);
        unhandledExceptionMessages.push(message);
    }
    median(baseline) {
        this.ctx.lastSnapCallPosition = caller();
        const assertions = this.createStatMethod("median", baseline);
        return assertions;
    }
    mean(baseline) {
        this.ctx.lastSnapCallPosition = caller();
        return this.createStatMethod("mean", baseline);
    }
    mark(baseline) {
        this.ctx.lastSnapCallPosition = caller();
        return this.createStatMethod("mark", baseline);
    }
}
const unhandledExceptionMessages = [];
const currentSuitePath = [];
process.on("beforeExit", () => {
    if (unhandledExceptionMessages.length) {
        console.error(`${unhandledExceptionMessages.length} unhandled exception(s) occurred during your benches (see details above).`);
        process.exit(1);
    }
});
export const getBenchCtx = (qualifiedPath, isAsync = false, options = {}) => ({
    qualifiedPath,
    qualifiedName: qualifiedPath.join("/"),
    options,
    cfg: getConfig(),
    benchCallPosition: caller(),
    lastSnapCallPosition: undefined,
    lastSnapFunctionName: undefined,
    isAsync,
    assertionStack: getCallStack({ offset: 1 }).join("\n")
});
